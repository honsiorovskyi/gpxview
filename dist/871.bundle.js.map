{"version":3,"file":"871.bundle.js","mappings":"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","sources":["webpack://gpx-viewer/./node_modules/@raruto/leaflet-elevation/libs/leaflet-hotline.js"],"sourcesContent":["/*\n(c) 2017, iosphere GmbH\nLeaflet.hotline, a Leaflet plugin for drawing gradients along polylines.\nhttps://github.com/iosphere/Leaflet.hotline/\n*/\n\n(function (root, plugin) {\n    /**\n     * UMD wrapper.\n     * When used directly in the Browser it expects Leaflet to be globally\n     * available as `L`. The plugin then adds itself to Leaflet.\n     * When used as a CommonJS module (e.g. with browserify) only the plugin\n     * factory gets exported, so one hast to call the factory manually and pass\n     * Leaflet as the only parameter.\n     * @see {@link https://github.com/umdjs/umd}\n     */\n    if (typeof define === 'function' && define.amd) {\n        define(['leaflet'], plugin);\n    } else if (typeof exports === 'object') {\n        module.exports = plugin;\n    } else {\n        plugin(root.L);\n    }\n}(window, function (L) {\n    // Plugin is already added to Leaflet\n    if (L.Hotline) {\n        return L;\n    }\n\n    /**\n     * Core renderer.\n     * @constructor\n     * @param {HTMLElement | string} canvas - &lt;canvas> element or its id\n     * to initialize the instance on.\n     */\n    var Hotline = function (canvas) {\n        if (!(this instanceof Hotline)) { return new Hotline(canvas); }\n\n        var defaultPalette = {\n            0.0: 'green',\n            0.5: 'yellow',\n            1.0: 'red'\n        };\n\n        this._canvas = canvas = ('string' === typeof canvas) \n            ? document.getElementById(canvas)\n            : canvas;\n\n        this._ctx = canvas.getContext('2d');\n        this._width = canvas.width;\n        this._height = canvas.height;\n\n        this._weight = 5;\n        this._outlineWidth = 1;\n        this._outlineColor = 'black';\n\n        this._min = 0;\n        this._max = 1;\n\n        this._data = [];\n\n        this.palette(defaultPalette);\n    };\n\n    Hotline.prototype = {\n        /**\n         * Sets the width of the canvas. Used when clearing the canvas.\n         * @param {number} width - Width of the canvas.\n         */\n        width: function (width) {\n            this._width = width;\n            return this;\n        },\n\n        /**\n         * Sets the height of the canvas. Used when clearing the canvas.\n         * @param {number} height - Height of the canvas.\n         */\n        height: function (height) {\n            this._height = height;\n            return this;\n        },\n\n        /**\n         * Sets the weight of the path.\n         * @param {number} weight - Weight of the path in px.\n         */\n        weight: function (weight) {\n            this._weight = weight;\n            return this;\n        },\n\n        /**\n         * Sets the width of the outline around the path.\n         * @param {number} outlineWidth - Width of the outline in px.\n         */\n        outlineWidth: function (outlineWidth) {\n            this._outlineWidth = outlineWidth;\n            return this;\n        },\n\n        /**\n         * Sets the color of the outline around the path.\n         * @param {string} outlineColor - A CSS color value.\n         */\n        outlineColor: function (outlineColor) {\n            this._outlineColor = outlineColor;\n            return this;\n        },\n\n        /**\n         * Sets the palette gradient.\n         * @param {Object.<number, string>} palette  - Gradient definition.\n         * e.g. { 0.0: 'white', 1.0: 'black' }\n         */\n        palette: function (palette) {\n            var canvas = document.createElement('canvas'),\n                ctx = canvas.getContext('2d'),\n                gradient = ctx.createLinearGradient(0, 0, 0, 256);\n\n            canvas.width = 1;\n            canvas.height = 256;\n\n            for (var i in palette) {\n                gradient.addColorStop(i, palette[i]);\n            }\n\n            ctx.fillStyle = gradient;\n            ctx.fillRect(0, 0, 1, 256);\n\n            this._palette = ctx.getImageData(0, 0, 1, 256).data;\n\n            return this;\n        },\n\n        /**\n         * Sets the value used at the start of the palette gradient.\n         * @param {number} min\n         */\n        min: function (min) {\n            this._min = min;\n            return this;\n        },\n\n        /**\n         * Sets the value used at the end of the palette gradient.\n         * @param {number} max\n         */\n        max: function (max) {\n            this._max = max;\n            return this;\n        },\n\n        /**\n         * A path to rander as a hotline.\n         * @typedef Array.<{x:number, y:number, z:number}> Path - Array of x, y and z coordinates.\n         */\n\n        /**\n         * Sets the data that gets drawn on the canvas.\n         * @param {(Path|Path[])} data - A single path or an array of paths.\n         */\n        data: function (data) {\n            this._data = data;\n            return this;\n        },\n\n        /**\n         * Adds a path to the list of paths.\n         * @param {Path} path\n         */\n        add: function (path) {\n            this._data.push(path);\n            return this;\n        },\n\n        /**\n         * Draws the currently set paths.\n         */\n        draw: function () {\n            var ctx = this._ctx;\n\n            ctx.globalCompositeOperation = 'source-over';\n            ctx.lineCap = 'round';\n\n            this._drawOutline(ctx);\n            this._drawHotline(ctx);\n\n            return this;\n        },\n\n        /**\n         * Gets the RGB values of a given z value of the current palette.\n         * @param {number} value - Value to get the color for, should be between min and max.\n         * @returns {Array.<number>} The RGB values as an array [r, g, b]\n         */\n        getRGBForValue: function (value) {\n            var valueRelative = Math.min(Math.max((value - this._min) / (this._max - this._min), 0), 0.999);\n            var paletteIndex = Math.floor(valueRelative * 256) * 4;\n\n            return [\n                this._palette[paletteIndex],\n                this._palette[paletteIndex + 1],\n                this._palette[paletteIndex + 2]\n            ];\n        },\n\n        /**\n         * Draws the outline of the graphs.\n         * @private\n         */\n        _drawOutline: function (ctx) {\n            var i, j, dataLength, path, pathLength, pointStart, pointEnd;\n\n            if (this._outlineWidth) {\n                for (i = 0, dataLength = this._data.length; i < dataLength; i++) {\n                    path = this._data[i];\n                    ctx.lineWidth = this._weight + 2 * this._outlineWidth;\n\n                    for (j = 1, pathLength = path.length; j < pathLength; j++) {\n                        pointStart = path[j - 1];\n                        pointEnd = path[j];\n\n                        ctx.strokeStyle = this._outlineColor;\n                        ctx.beginPath();\n                        ctx.moveTo(pointStart.x, pointStart.y);\n                        ctx.lineTo(pointEnd.x, pointEnd.y);\n                        ctx.stroke();\n                    }\n                }\n            }\n        },\n\n        /**\n         * Draws the color encoded hotline of the graphs.\n         * @private\n         */\n        _drawHotline: function (ctx) {\n            var i, j, dataLength, path, pathLength, pointStart, pointEnd,\n                gradient, gradientStartRGB, gradientEndRGB;\n\n            ctx.lineWidth = this._weight;\n\n            for (i = 0, dataLength = this._data.length; i < dataLength; i++) {\n                path = this._data[i];\n\n                for (j = 1, pathLength = path.length; j < pathLength; j++) {\n                    pointStart = path[j - 1];\n                    pointEnd = path[j];\n\n                    // Create a gradient for each segment, pick start end end colors from palette gradient\n                    gradient = ctx.createLinearGradient(pointStart.x, pointStart.y, pointEnd.x, pointEnd.y);\n                    gradientStartRGB = this.getRGBForValue(pointStart.z);\n                    gradientEndRGB = this.getRGBForValue(pointEnd.z);\n                    gradient.addColorStop(0, 'rgb(' + gradientStartRGB.join(',') + ')');\n                    gradient.addColorStop(1, 'rgb(' + gradientEndRGB.join(',') + ')');\n\n                    ctx.strokeStyle = gradient;\n                    ctx.beginPath();\n                    ctx.moveTo(pointStart.x, pointStart.y);\n                    ctx.lineTo(pointEnd.x, pointEnd.y);\n                    ctx.stroke();\n                }\n            }\n        }\n    };\n\n\n    var Renderer = L.Canvas.extend({\n        _initContainer: function () {\n            L.Canvas.prototype._initContainer.call(this);\n            this._hotline = new Hotline(this._container);\n        },\n\n        _update: function () {\n            L.Canvas.prototype._update.call(this);\n            this._hotline.width(this._container.width);\n            this._hotline.height(this._container.height);\n        },\n\n        _updatePoly: function (layer) {\n            if (!this._drawing) { return; }\n\n            var parts = layer._parts;\n\n            if (!parts.length) { return; }\n\n            this._updateOptions(layer);\n\n            this._hotline\n                .data(parts)\n                .draw();\n        },\n\n        _updateOptions: function (layer) {\n            if (layer.options.min != null) {\n                this._hotline.min(layer.options.min);\n            }\n            if (layer.options.max != null) {\n                this._hotline.max(layer.options.max);\n            }\n            if (layer.options.weight != null) {\n                this._hotline.weight(layer.options.weight);\n            }\n            if (layer.options.outlineWidth != null) {\n                this._hotline.outlineWidth(layer.options.outlineWidth);\n            }\n            if (layer.options.outlineColor != null) {\n                this._hotline.outlineColor(layer.options.outlineColor);\n            }\n            if (layer.options.palette) {\n                this._hotline.palette(layer.options.palette);\n            }\n        }\n    });\n\n    var renderer = function (options) {\n        return L.Browser.canvas ? new Renderer(options) : null;\n    };\n\n\n    var Util = {\n        /**\n         * This is just a copy of the original Leaflet version that support a third z coordinate.\n         * @see {@link http://leafletjs.com/reference.html#lineutil-clipsegment|Leaflet}\n         */\n        clipSegment: function (a, b, bounds, useLastCode, round) {\n            var codeA = useLastCode ? this._lastCode : L.LineUtil._getBitCode(a, bounds),\n                codeB = L.LineUtil._getBitCode(b, bounds),\n                codeOut, p, newCode;\n\n            // save 2nd code to avoid calculating it on the next segment\n            this._lastCode = codeB;\n\n            while (true) {\n                // if a,b is inside the clip window (trivial accept)\n                if (!(codeA | codeB)) {\n                    return [a, b];\n                    // if a,b is outside the clip window (trivial reject)\n                } else if (codeA & codeB) {\n                    return false;\n                    // other cases\n                } else {\n                    codeOut = codeA || codeB;\n                    p = L.LineUtil._getEdgeIntersection(a, b, codeOut, bounds, round);\n                    newCode = L.LineUtil._getBitCode(p, bounds);\n\n                    if (codeOut === codeA) {\n                        p.z = a.z;\n                        a = p;\n                        codeA = newCode;\n                    } else {\n                        p.z = b.z;\n                        b = p;\n                        codeB = newCode;\n                    }\n                }\n            }\n        }\n    };\n\n\n    L.Hotline = L.Polyline.extend({\n        statics: {\n            Renderer: Renderer,\n            renderer: renderer\n        },\n\n        options: {\n            renderer: renderer(),\n            min: 0,\n            max: 1,\n            palette: {\n                0.0: 'green',\n                0.5: 'yellow',\n                1.0: 'red'\n            },\n            weight: 5,\n            outlineColor: 'black',\n            outlineWidth: 1\n        },\n\n        getRGBForValue: function (value) {\n            return this._renderer._hotline.getRGBForValue(value);\n        },\n\n        /**\n         * Just like the Leaflet version, but with support for a z coordinate.\n         */\n        _projectLatlngs: function (latlngs, result, projectedBounds) {\n            var flat = latlngs[0] instanceof L.LatLng,\n                len = latlngs.length,\n                i, ring;\n\n            if (flat) {\n                ring = [];\n                for (i = 0; i < len; i++) {\n                    ring[i] = this._map.latLngToLayerPoint(latlngs[i]);\n                    // Add the altitude of the latLng as the z coordinate to the point\n                    ring[i].z = latlngs[i].alt;\n                    projectedBounds.extend(ring[i]);\n                }\n                result.push(ring);\n            } else {\n                for (i = 0; i < len; i++) {\n                    this._projectLatlngs(latlngs[i], result, projectedBounds);\n                }\n            }\n        },\n\n        /**\n         * Just like the Leaflet version, but uses `Util.clipSegment()`.\n         */\n        _clipPoints: function () {\n            if (this.options.noClip) {\n                this._parts = this._rings;\n                return;\n            }\n\n            this._parts = [];\n\n            var parts = this._parts,\n                bounds = this._renderer._bounds,\n                i, j, k, len, len2, segment, points;\n\n            for (i = 0, k = 0, len = this._rings.length; i < len; i++) {\n                points = this._rings[i];\n\n                for (j = 0, len2 = points.length; j < len2 - 1; j++) {\n                    segment = Util.clipSegment(points[j], points[j + 1], bounds, j, true);\n\n                    if (!segment) { continue; }\n\n                    parts[k] = parts[k] || [];\n                    parts[k].push(segment[0]);\n\n                    // if segment goes out of screen, or it's the last one, it's the end of the line part\n                    if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {\n                        parts[k].push(segment[1]);\n                        k++;\n                    }\n                }\n            }\n        },\n\n        _clickTolerance: function () {\n            return this.options.weight / 2 + this.options.outlineWidth + (L.Browser.touch ? 10 : 0);\n        }\n    });\n\n    L.hotline = function (latlngs, options) {\n        return new L.Hotline(latlngs, options);\n    };\n\n\n    return L;\n}));"],"names":["root","plugin","window","L","Hotline","canvas","this","_canvas","document","getElementById","_ctx","getContext","_width","width","_height","height","_weight","_outlineWidth","_outlineColor","_min","_max","_data","palette","prototype","weight","outlineWidth","outlineColor","createElement","ctx","gradient","createLinearGradient","i","addColorStop","fillStyle","fillRect","_palette","getImageData","data","min","max","add","path","push","draw","globalCompositeOperation","lineCap","_drawOutline","_drawHotline","getRGBForValue","value","valueRelative","Math","paletteIndex","floor","j","dataLength","pathLength","pointStart","pointEnd","length","lineWidth","strokeStyle","beginPath","moveTo","x","y","lineTo","stroke","gradientStartRGB","gradientEndRGB","z","join","Renderer","Canvas","extend","_initContainer","call","_hotline","_container","_update","_updatePoly","layer","_drawing","parts","_parts","_updateOptions","options","renderer","Browser","Util","clipSegment","a","b","bounds","useLastCode","round","codeOut","p","newCode","codeA","_lastCode","LineUtil","_getBitCode","codeB","_getEdgeIntersection","Polyline","statics","_renderer","_projectLatlngs","latlngs","result","projectedBounds","ring","flat","LatLng","len","_map","latLngToLayerPoint","alt","_clipPoints","noClip","_rings","k","len2","segment","points","_bounds","_clickTolerance","touch","hotline","define","amd","exports","module"],"sourceRoot":""}